// Generated by dts-bundle-generator v9.5.1

/**
Represents an object with `unknown` value. You probably want this instead of `{}`.

Use case: You have an object whose keys and values are unknown to you.

@example
```
import type {UnknownRecord} from 'type-fest';

function toJson(object: UnknownRecord) {
	return JSON.stringify(object);
}

toJson({hello: 'world'});
//=> '{"hello":"world"}'

function isObject(value: unknown): value is UnknownRecord {
	return typeof value === 'object' && value !== null;
}

isObject({hello: 'world'});
//=> true

isObject('hello');
//=> false
```

@category Type
@category Object
*/
export type UnknownRecord = Record<PropertyKey, unknown>;
/**
Represents an array with `unknown` value.

Use case: You want a type that all arrays can be assigned to, but you don't care about the value.

@example
```
import type {UnknownArray} from 'type-fest';

type IsArray<T> = T extends UnknownArray ? true : false;

type A = IsArray<['foo']>;
//=> true

type B = IsArray<readonly number[]>;
//=> true

type C = IsArray<string>;
//=> false
```

@category Type
@category Array
*/
export type UnknownArray = readonly unknown[];
export type ArrayOrPlainObject = UnknownArray | UnknownRecord;
export type Key = number | string;
export type PlainObject = UnknownRecord;
export type EffectState = {
	active: boolean;
	callback: () => void;
	reactives: Set<ReactiveState<unknown>>;
};
export type ReactiveCallbacks<Value> = {
	any: Set<EffectState | Subscriber<Value>>;
	keys: Set<Key>;
	values: Map<Key, Set<EffectState | Subscriber<Value>>>;
};
export type ReactiveState<Value> = {
	active: boolean;
	callbacks: ReactiveCallbacks<Value>;
	value: Value;
};
/**
 * A subscriber for a reactive value, called when the value changes
 */
export type Subscriber<Value> = (value: Value) => void;
/**
 * - A function that unsubscribes a subscriber from a reactive value
 * - Receieved when subscribing to a reactive value
 */
export type Unsubscriber = () => void;
/**
 * A reactive effect for changes in a value
 */
export declare class Effect {
	private readonly $sentinel;
	private readonly state;
	constructor(callback: () => void);
	/**
	 * Starts reacting to changes
	 */
	start(): void;
	/**
	 * Stops reacting to changes
	 */
	stop(): void;
}
/**
 * Creates a reactive effect
 */
export declare function effect(callback: () => void): Effect;
declare abstract class ReactiveInstance<Value = unknown> {
	private readonly $sentinel;
	protected readonly state: ReactiveState<Value>;
	constructor(type: string, value: Value);
	/**
	 * Gets the value
	 */
	get(): Value;
	/**
	 * Gets the value without triggering reactivity
	 */
	peek(): Value;
	/**
	 * Starts reactivity for the value, if it was stopped
	 */
	run(): void;
	/**
	 * Stops reactivity for the value, if it was started
	 */
	stop(): void;
	/**
	 * Gets the JSON representation of the value
	 */
	toJSON(): Value;
	/**
	 * Gets the string representation of the value
	 */
	toString(): string;
}
export type Reactive = ReactiveInstance;
declare class ReactiveValue<Value> extends ReactiveInstance<Value> {
	/**
	 * - Subscribes to changes for the value
	 * - Returns a function to allow for unsubscribing
	 */
	subscribe(subscriber: Subscriber<Value>): Unsubscriber;
	/**
	 * Unsubscribes from changes for the value _(and optionally a specific subscriber)_
	 */
	unsubscribe(subscriber?: Subscriber<Value>): void;
}
/**
 * A computed, reactive value
 */
export declare class Computed<Value> extends ReactiveValue<Value> {
	private readonly fx;
	constructor(value: () => Value);
	/**
	 * @inheritdoc
	 */
	run(): void;
	/**
	 * @inheritdoc
	 */
	stop(): void;
}
/**
 * Creates a computed, reactive value
 */
export declare function computed<Value>(value: () => Value): Computed<Value>;
export declare class Signal<Value> extends ReactiveValue<Value> {
	constructor(value: Value);
	/**
	 * Sets the value
	 */
	set(value: Value): void;
	/**
	 * Updates the value
	 */
	update(updater: (current: Value) => Value): void;
}
/**
 * Creates a reactive value
 */
export declare function signal<Value>(value: Value): Signal<Value>;
declare abstract class ReactiveObject<Value extends ArrayOrPlainObject> extends ReactiveInstance<Value> {
	constructor(type: string, value: Value, length?: Signal<number>);
}
export declare class ReactiveArray<Value> extends ReactiveObject<Value[]> {
	private readonly arrayLength;
	/**
	 * Get the length of the array
	 */
	get length(): number;
	/**
	 * Set the length of the array
	 */
	set length(value: number);
	constructor(value: Value[], arrayLength: Signal<number>);
	/**
	 * Calls a callback function on each value in the array, and returns a computed, reactive value that contains the results
	 */
	filter(callbackFn: (value: Value, index: number, array: Value[]) => boolean): Computed<Value[]>;
	/**
	 * Gets the array
	 */
	get(): Value[];
	/**
	 * Gets the value for an index
	 */
	get<Index extends keyof Value[]>(index: Index): Value[][Index];
	/**
	 * Inserts values at a specific index, and returns the new length of the array
	 */
	insert(index: number, ...value: Value[]): number;
	/**
	 * Calls a callback function on each value in the array, and returns a computed, reactive value that contains the results
	 */
	map<Next>(callbackfn: (value: Value, index: number, array: Value[]) => Next): Computed<Next[]>;
	/**
	 * Gets the value without triggering reactivity
	 */
	peek(): Value[];
	/**
	 * Gets the value for an index without triggering reactivity
	 */
	peek<Index extends keyof Value[]>(index: Index): Value[][Index];
	/**
	 * Appends new values to the end of the array, and returns the new length of the array
	 */
	push(...values: Value[]): number;
	/**
	 * Sets the value _(and returns the previous value)_
	 */
	set(value: Value[]): void;
	/**
	 * Sets the value for an index
	 */
	set<Index extends keyof Value[]>(index: Index, value: Value[][Index]): void;
	/**
	 * Removes values from the array and, if necessary, inserts new values in their place, returning the deleted values
	 */
	splice(start: number, deleteCount?: number, ...values: Value[]): Value[];
	/**
	 * - Subscribes to changes for a specific index in the array
	 * - Returns a function to allow for unsubscribing
	 */
	subscribe<Index extends keyof Value[]>(index: Index, subscriber: Subscriber<Value[][Index]>): Unsubscriber;
	/**
	 * - Subscribes to changes for the array
	 * - Returns a function to allow for unsubscribing
	 */
	subscribe(subscriber: Subscriber<Value[]>): Unsubscriber;
	/**
	 * Gets a shallow copy of the array
	 */
	toArray(): Value[];
	/**
	 * Unsubscribes from changes for a specific index in the array _(and optionally a specific subscriber)_
	 */
	unsubscribe<Index extends keyof Value[]>(index: Index, subscriber?: Subscriber<Value[][Index]>): void;
	/**
	 * Unsubscribes from changes for the array _(and optionally a specific subscriber)_
	 */
	unsubscribe(subscriber?: Subscriber<unknown>): void;
}
export declare function array<Value>(value: Value[]): ReactiveArray<Value>;
export declare class Store<Value extends PlainObject> extends ReactiveObject<Value> {
	constructor(value: Value);
	/**
	 * Gets the store without triggering reactivity
	 */
	peek(): Value;
	/**
	 * Gets the value for a path without triggering reactivity
	 */
	peek<Key extends keyof Value>(key: Key): Value[Key];
	/**
	 * Sets the value for a key
	 */
	set<Key extends keyof Value>(key: Key, value: unknown): void;
	/**
	 * - Subscribes to changes for a specific key in the store
	 * - Returns a function to allow for unsubscribing
	 */
	subscribe<Key extends keyof Value>(key: Key, subscriber: Subscriber<Value[Key]>): Unsubscriber;
	/**
	 * - Subscribes to changes for the store
	 * - Returns a function to allow for unsubscribing
	 */
	subscribe(subscriber: Subscriber<unknown>): Unsubscriber;
	/**
	 * Unsubscribes from changes for a specific key in the store _(and optionally a specific subscriber)_
	 */
	unsubscribe<Key extends keyof Value>(key: Key, subscriber?: Subscriber<Value[Key]>): void;
	/**
	 * Unsubscribes from changes for the store _(and optionally a specific subscriber)_
	 */
	unsubscribe(subscriber?: Subscriber<unknown>): void;
}
export declare function store<Value extends PlainObject>(value: Value): Store<Value>;
/**
 * Is the value a reactive array?
 */
export declare function isArray(value: unknown): value is ReactiveArray<unknown>;
/**
 * Is the value a computed, reactive value?
 */
export declare function isComputed(value: unknown): value is Computed<unknown>;
/**
 * Is the value a reactive effect?
 */
export declare function isEffect(value: unknown): value is Effect;
/**
 * Is the value a reactive value?
 */
export declare function isReactive(value: unknown): value is Reactive;
/**
 * Is the value a reactive store?
 */
export declare function isStore(value: unknown): value is Store<PlainObject>;
/**
 * Is the value a reactive value?
 */
export declare function isSignal(value: unknown): value is Signal<unknown>;
/**
 * Creates a reactive array
 */
export declare function reactive<Value extends unknown[]>(value: Value): ReactiveArray<Value>;
/**
 * Creates a reactive store
 */
export declare function reactive<Value extends PlainObject>(value: Value): Store<Value>;
/**
 * Creates a computed, reactive value
 */
export declare function reactive<Value>(callback: () => Value): Computed<Value>;
/**
 * Creates a reactive value
 */
export declare function reactive<Value>(value: Value): Signal<Value>;

export {};
